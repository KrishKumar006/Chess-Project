import chess
import chess.pgn
import chess.engine
import io

STOCKFISH_PATH = r"STOCKFISH PATH HERE"

def eco_style_bonus(pgn_game):
    """
    Compute ECO book exit bonus: +0.5 pts per move earlier than ply 20
    """
    node = pgn_game
    ply_count = 0
    while node.variations:
        node = node.variations[0]
        ply_count += 1
        if node.comment and "book" not in node.comment.lower():
            break  # found exit from book
    exit_ply = ply_count
    bonus = max(0, (20 - exit_ply) * 0.5)
    return bonus

def sacrifice_style_bonus(pgn_game, engine, time_limit=0.5):
    """
    +10 if a sac drops 3+ points, eval >=0 before and stays >=0 for 5 plies after
    """
    board = pgn_game.board()
    moves = list(pgn_game.mainline_moves())
    bonus_given = False

    for i in range(len(moves) - 5):  # need room for 5 moves after
        white_before = bin(board.occupied_co[chess.WHITE]).count("1")
        black_before = bin(board.occupied_co[chess.BLACK]).count("1")
        mat_before = white_before - black_before

        # Evaluate before move
        info_before = engine.analyse(board, chess.engine.Limit(time=time_limit))
        eval_before = info_before["score"].relative.score(mate_score=10000)

        board.push(moves[i])  # make the potential sac move

        white_after = bin(board.occupied_co[chess.WHITE]).count("1")
        black_after = bin(board.occupied_co[chess.BLACK]).count("1")
        mat_after = white_after - black_after

        material_drop = abs(mat_after - mat_before)

        if material_drop >= 3:
            if eval_before is None:
                continue
            if eval_before >= 0:
                eval_good = True
                tmp_board = board.copy()
                for j in range(1, 6):
                    if i + j >= len(moves):
                        break
                    tmp_board.push(moves[i + j])
                    info_future = engine.analyse(tmp_board, chess.engine.Limit(time=time_limit))
                    future_eval = info_future["score"].relative.score(mate_score=10000)
                    if future_eval is None or future_eval < 0:
                        eval_good = False
                        break
                if eval_good:
                    bonus_given = True
                    break
    return 10 if bonus_given else 0


    for i in range(len(moves) - 5):  # need room for 5 moves after
        mat_before = board.occupied_co[chess.WHITE].popcount() - board.occupied_co[chess.BLACK].popcount()
        # Evaluate before move
        info_before = engine.analyse(board, chess.engine.Limit(time=time_limit))
        eval_before = info_before["score"].relative.score(mate_score=10000)

        board.push(moves[i])  # make the potential sac move
        mat_after = board.occupied_co[chess.WHITE].popcount() - board.occupied_co[chess.BLACK].popcount()
        material_drop = abs(mat_after - mat_before)

        # Check for significant material drop (sac)
        if material_drop >= 3:
            # Check eval before sac: side's eval must be >=0
            if eval_before is None:
                continue

            if eval_before >= 0:
                # Check eval stays good for next 5 plies
                eval_good = True
                tmp_board = board.copy()
                for j in range(1, 6):
                    if i + j >= len(moves):
                        break
                    tmp_board.push(moves[i + j])
                    info_future = engine.analyse(tmp_board, chess.engine.Limit(time=time_limit))
                    future_eval = info_future["score"].relative.score(mate_score=10000)
                    if future_eval is None or future_eval < 0:
                        eval_good = False
                        break
                if eval_good:
                    bonus_given = True
                    break
        # continue checking next move
    return 10 if bonus_given else 0

def top_line_style_bonus(pgn_game, engine, time_limit=0.5):
    """
    +2 for each move that's the only best line (second best worse by >=200cp)
    """
    board = pgn_game.board()
    moves = list(pgn_game.mainline_moves())
    bonus = 0

    for move in moves:
        board.push(move)
        info = engine.analyse(board, chess.engine.Limit(time=time_limit), multipv=2)
        # multipv=2 gives top two moves
        if len(info) < 2:
            continue
        first_cp = info[0]["score"].relative.score(mate_score=10000)
        second_cp = info[1]["score"].relative.score(mate_score=10000)

        if first_cp is None or second_cp is None:
            continue

        # Large difference = unique top move
        if abs(first_cp - second_cp) >= 200:
            bonus += 2

    return bonus

def compute_style_score_from_pgn(pgn_string, time_limit=0.5):
    game = chess.pgn.read_game(io.StringIO(pgn_string.strip()))
    engine = chess.engine.SimpleEngine.popen_uci(STOCKFISH_PATH)

    score = 0
    score += eco_style_bonus(game)
    score += sacrifice_style_bonus(game, engine, time_limit)
    score += top_line_style_bonus(game, engine, time_limit)

    engine.quit()
    return score

if __name__ == "__main__":
    pgn = """PGN HERE"""

    style_score = compute_style_score_from_pgn(pgn, time_limit=0.5)
    print(f"Style score for PGN: {style_score:.2f}")
