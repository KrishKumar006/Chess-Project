import chess
import chess.pgn
import chess.engine
import io

STOCKFISH_PATH = r"STOCKFISH PATH HERE"

def compute_technical_score_from_pgn(pgn_string, time_limit=0.3):
    game = chess.pgn.read_game(io.StringIO(pgn_string.strip()))
    if game is None:
        print("PGN parsing failed.")
        return 0

    board = game.board()
    engine = chess.engine.SimpleEngine.popen_uci(STOCKFISH_PATH)

    evals = []
    acpl_sum = 0
    blunders = 0
    prev_eval_cp = None

    moves = list(game.mainline_moves())
    print(f"Total moves: {len(moves)}")

    for i, move in enumerate(moves):
        board.push(move)
        try:
            info = engine.analyse(board, chess.engine.Limit(time=time_limit))
        except Exception as e:
            print(f"Engine failed at move {i}: {e}")
            evals.append(None)
            continue

        score = info["score"].relative
        if score.is_mate():
            cp = None  # Completely skip for ACPL/blunder calculations
        else:
            cp = score.score()

        evals.append(cp)
        print(f"Move {i+1}: {move}, Eval: {cp}")

        if prev_eval_cp is not None and cp is not None:
            diff = abs(cp - prev_eval_cp)
            acpl_sum += diff
            if diff >= 300:
                blunders += 1

        prev_eval_cp = cp

    engine.quit()

    evals_non_none = [e for e in evals if e is not None]
    num_moves = max(1, len(evals_non_none) - 1)
    avg_acpl = acpl_sum / num_moves

    print(f"ACPL sum: {acpl_sum}")
    print(f"Blunders: {blunders}")
    print(f"Avg ACPL: {avg_acpl}")
    print(f"Eval count: {len(evals_non_none)}")

    technical = 100 - min(100, 0.04 * avg_acpl) - 3 * blunders
    final_score = max(0, technical)
    print(f"Technical score: {final_score}")
    return final_score

# Example PGN (Insert your PGN here)
pgn = """PGN HERE"""

compute_technical_score_from_pgn(pgn)
